// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: ride/payments/v1alpha1/service.proto

package paymentsv1alpha1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on GetWalletRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetWalletRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWalletRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetWalletRequestMultiError, or nil if none found.
func (m *GetWalletRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWalletRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GetWalletRequest_Name_Pattern.MatchString(m.GetName()) {
		err := GetWalletRequestValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^users/[A-Za-z0-9_-]+/wallet$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Fields != nil {

		if all {
			switch v := interface{}(m.GetFields()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetWalletRequestValidationError{
						field:  "Fields",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetWalletRequestValidationError{
						field:  "Fields",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFields()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetWalletRequestValidationError{
					field:  "Fields",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetWalletRequestMultiError(errors)
	}

	return nil
}

// GetWalletRequestMultiError is an error wrapping multiple validation errors
// returned by GetWalletRequest.ValidateAll() if the designated constraints
// aren't met.
type GetWalletRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWalletRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWalletRequestMultiError) AllErrors() []error { return m }

// GetWalletRequestValidationError is the validation error returned by
// GetWalletRequest.Validate if the designated constraints aren't met.
type GetWalletRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWalletRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWalletRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWalletRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWalletRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWalletRequestValidationError) ErrorName() string { return "GetWalletRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetWalletRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWalletRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWalletRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWalletRequestValidationError{}

var _GetWalletRequest_Name_Pattern = regexp.MustCompile("^users/[A-Za-z0-9_-]+/wallet$")

// Validate checks the field values on GetWalletResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetWalletResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWalletResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetWalletResponseMultiError, or nil if none found.
func (m *GetWalletResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWalletResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetWallet()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetWalletResponseValidationError{
					field:  "Wallet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetWalletResponseValidationError{
					field:  "Wallet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWallet()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetWalletResponseValidationError{
				field:  "Wallet",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetWalletResponseMultiError(errors)
	}

	return nil
}

// GetWalletResponseMultiError is an error wrapping multiple validation errors
// returned by GetWalletResponse.ValidateAll() if the designated constraints
// aren't met.
type GetWalletResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWalletResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWalletResponseMultiError) AllErrors() []error { return m }

// GetWalletResponseValidationError is the validation error returned by
// GetWalletResponse.Validate if the designated constraints aren't met.
type GetWalletResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWalletResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWalletResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWalletResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWalletResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWalletResponseValidationError) ErrorName() string {
	return "GetWalletResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetWalletResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWalletResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWalletResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWalletResponseValidationError{}

// Validate checks the field values on CreateTransfersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTransfersRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTransfersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTransfersRequestMultiError, or nil if none found.
func (m *CreateTransfersRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransfersRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequestId

	if len(m.GetTransfers()) < 1 {
		err := CreateTransfersRequestValidationError{
			field:  "Transfers",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetTransfers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTransfersRequestValidationError{
						field:  fmt.Sprintf("Transfers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTransfersRequestValidationError{
						field:  fmt.Sprintf("Transfers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTransfersRequestValidationError{
					field:  fmt.Sprintf("Transfers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateTransfersRequestMultiError(errors)
	}

	return nil
}

// CreateTransfersRequestMultiError is an error wrapping multiple validation
// errors returned by CreateTransfersRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateTransfersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransfersRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransfersRequestMultiError) AllErrors() []error { return m }

// CreateTransfersRequestValidationError is the validation error returned by
// CreateTransfersRequest.Validate if the designated constraints aren't met.
type CreateTransfersRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransfersRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransfersRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransfersRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransfersRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransfersRequestValidationError) ErrorName() string {
	return "CreateTransfersRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransfersRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransfersRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransfersRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransfersRequestValidationError{}

// Validate checks the field values on CreateTransfersResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTransfersResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTransfersResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTransfersResponseMultiError, or nil if none found.
func (m *CreateTransfersResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransfersResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BatchId

	if len(m.GetTransfers()) < 1 {
		err := CreateTransfersResponseValidationError{
			field:  "Transfers",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetTransfers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTransfersResponseValidationError{
						field:  fmt.Sprintf("Transfers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTransfersResponseValidationError{
						field:  fmt.Sprintf("Transfers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTransfersResponseValidationError{
					field:  fmt.Sprintf("Transfers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateTransfersResponseMultiError(errors)
	}

	return nil
}

// CreateTransfersResponseMultiError is an error wrapping multiple validation
// errors returned by CreateTransfersResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateTransfersResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransfersResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransfersResponseMultiError) AllErrors() []error { return m }

// CreateTransfersResponseValidationError is the validation error returned by
// CreateTransfersResponse.Validate if the designated constraints aren't met.
type CreateTransfersResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransfersResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransfersResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransfersResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransfersResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransfersResponseValidationError) ErrorName() string {
	return "CreateTransfersResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransfersResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransfersResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransfersResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransfersResponseValidationError{}

// Validate checks the field values on CreateTransactionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTransactionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTransactionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTransactionsRequestMultiError, or nil if none found.
func (m *CreateTransactionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequestId

	if len(m.GetEntries()) < 2 {
		err := CreateTransactionsRequestValidationError{
			field:  "Entries",
			reason: "value must contain at least 2 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetEntries() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTransactionsRequestValidationError{
						field:  fmt.Sprintf("Entries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTransactionsRequestValidationError{
						field:  fmt.Sprintf("Entries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTransactionsRequestValidationError{
					field:  fmt.Sprintf("Entries[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateTransactionsRequestMultiError(errors)
	}

	return nil
}

// CreateTransactionsRequestMultiError is an error wrapping multiple validation
// errors returned by CreateTransactionsRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateTransactionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionsRequestMultiError) AllErrors() []error { return m }

// CreateTransactionsRequestValidationError is the validation error returned by
// CreateTransactionsRequest.Validate if the designated constraints aren't met.
type CreateTransactionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionsRequestValidationError) ErrorName() string {
	return "CreateTransactionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionsRequestValidationError{}

// Validate checks the field values on CreateTransactionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTransactionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTransactionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTransactionsResponseMultiError, or nil if none found.
func (m *CreateTransactionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BatchId

	if len(m.GetTransactions()) < 2 {
		err := CreateTransactionsResponseValidationError{
			field:  "Transactions",
			reason: "value must contain at least 2 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTransactionsResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTransactionsResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTransactionsResponseValidationError{
					field:  fmt.Sprintf("Transactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateTransactionsResponseMultiError(errors)
	}

	return nil
}

// CreateTransactionsResponseMultiError is an error wrapping multiple
// validation errors returned by CreateTransactionsResponse.ValidateAll() if
// the designated constraints aren't met.
type CreateTransactionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionsResponseMultiError) AllErrors() []error { return m }

// CreateTransactionsResponseValidationError is the validation error returned
// by CreateTransactionsResponse.Validate if the designated constraints aren't met.
type CreateTransactionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionsResponseValidationError) ErrorName() string {
	return "CreateTransactionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionsResponseValidationError{}

// Validate checks the field values on GetTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTransactionRequestMultiError, or nil if none found.
func (m *GetTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GetTransactionRequest_Name_Pattern.MatchString(m.GetName()) {
		err := GetTransactionRequestValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^users/[A-Za-z0-9_-]+/wallet/transactions/[A-Za-z0-9_-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Fields != nil {

		if all {
			switch v := interface{}(m.GetFields()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTransactionRequestValidationError{
						field:  "Fields",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTransactionRequestValidationError{
						field:  "Fields",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFields()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTransactionRequestValidationError{
					field:  "Fields",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetTransactionRequestMultiError(errors)
	}

	return nil
}

// GetTransactionRequestMultiError is an error wrapping multiple validation
// errors returned by GetTransactionRequest.ValidateAll() if the designated
// constraints aren't met.
type GetTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionRequestMultiError) AllErrors() []error { return m }

// GetTransactionRequestValidationError is the validation error returned by
// GetTransactionRequest.Validate if the designated constraints aren't met.
type GetTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionRequestValidationError) ErrorName() string {
	return "GetTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionRequestValidationError{}

var _GetTransactionRequest_Name_Pattern = regexp.MustCompile("^users/[A-Za-z0-9_-]+/wallet/transactions/[A-Za-z0-9_-]+$")

// Validate checks the field values on GetTransactionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTransactionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransactionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTransactionResponseMultiError, or nil if none found.
func (m *GetTransactionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransactionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTransactionResponseValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTransactionResponseValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTransactionResponseValidationError{
				field:  "Transaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTransactionResponseMultiError(errors)
	}

	return nil
}

// GetTransactionResponseMultiError is an error wrapping multiple validation
// errors returned by GetTransactionResponse.ValidateAll() if the designated
// constraints aren't met.
type GetTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionResponseMultiError) AllErrors() []error { return m }

// GetTransactionResponseValidationError is the validation error returned by
// GetTransactionResponse.Validate if the designated constraints aren't met.
type GetTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionResponseValidationError) ErrorName() string {
	return "GetTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionResponseValidationError{}

// Validate checks the field values on ListTransactionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTransactionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTransactionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTransactionsRequestMultiError, or nil if none found.
func (m *ListTransactionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTransactionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ListTransactionsRequest_Parent_Pattern.MatchString(m.GetParent()) {
		err := ListTransactionsRequestValidationError{
			field:  "Parent",
			reason: "value does not match regex pattern \"^users/[A-Za-z0-9_-]+/wallet$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PageSize

	// no validation rules for PageToken

	if m.Fields != nil {

		if all {
			switch v := interface{}(m.GetFields()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListTransactionsRequestValidationError{
						field:  "Fields",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListTransactionsRequestValidationError{
						field:  "Fields",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFields()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListTransactionsRequestValidationError{
					field:  "Fields",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListTransactionsRequestMultiError(errors)
	}

	return nil
}

// ListTransactionsRequestMultiError is an error wrapping multiple validation
// errors returned by ListTransactionsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListTransactionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTransactionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTransactionsRequestMultiError) AllErrors() []error { return m }

// ListTransactionsRequestValidationError is the validation error returned by
// ListTransactionsRequest.Validate if the designated constraints aren't met.
type ListTransactionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTransactionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTransactionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTransactionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTransactionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTransactionsRequestValidationError) ErrorName() string {
	return "ListTransactionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListTransactionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTransactionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTransactionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTransactionsRequestValidationError{}

var _ListTransactionsRequest_Parent_Pattern = regexp.MustCompile("^users/[A-Za-z0-9_-]+/wallet$")

// Validate checks the field values on ListTransactionsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTransactionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTransactionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTransactionsResponseMultiError, or nil if none found.
func (m *ListTransactionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTransactionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListTransactionsResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListTransactionsResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListTransactionsResponseValidationError{
					field:  fmt.Sprintf("Transactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return ListTransactionsResponseMultiError(errors)
	}

	return nil
}

// ListTransactionsResponseMultiError is an error wrapping multiple validation
// errors returned by ListTransactionsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListTransactionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTransactionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTransactionsResponseMultiError) AllErrors() []error { return m }

// ListTransactionsResponseValidationError is the validation error returned by
// ListTransactionsResponse.Validate if the designated constraints aren't met.
type ListTransactionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTransactionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTransactionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTransactionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTransactionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTransactionsResponseValidationError) ErrorName() string {
	return "ListTransactionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListTransactionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTransactionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTransactionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTransactionsResponseValidationError{}

// Validate checks the field values on CreateRechargeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateRechargeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRechargeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateRechargeRequestMultiError, or nil if none found.
func (m *CreateRechargeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRechargeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequestId

	if !_CreateRechargeRequest_Parent_Pattern.MatchString(m.GetParent()) {
		err := CreateRechargeRequestValidationError{
			field:  "Parent",
			reason: "value does not match regex pattern \"^users/[A-Za-z0-9_-]+/wallet$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetRecharge() == nil {
		err := CreateRechargeRequestValidationError{
			field:  "Recharge",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRecharge()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateRechargeRequestValidationError{
					field:  "Recharge",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateRechargeRequestValidationError{
					field:  "Recharge",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRecharge()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateRechargeRequestValidationError{
				field:  "Recharge",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateRechargeRequestMultiError(errors)
	}

	return nil
}

// CreateRechargeRequestMultiError is an error wrapping multiple validation
// errors returned by CreateRechargeRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateRechargeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRechargeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRechargeRequestMultiError) AllErrors() []error { return m }

// CreateRechargeRequestValidationError is the validation error returned by
// CreateRechargeRequest.Validate if the designated constraints aren't met.
type CreateRechargeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRechargeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRechargeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRechargeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRechargeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRechargeRequestValidationError) ErrorName() string {
	return "CreateRechargeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateRechargeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRechargeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRechargeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRechargeRequestValidationError{}

var _CreateRechargeRequest_Parent_Pattern = regexp.MustCompile("^users/[A-Za-z0-9_-]+/wallet$")

// Validate checks the field values on CreateRechargeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateRechargeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRechargeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateRechargeResponseMultiError, or nil if none found.
func (m *CreateRechargeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRechargeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRecharge() == nil {
		err := CreateRechargeResponseValidationError{
			field:  "Recharge",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRecharge()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateRechargeResponseValidationError{
					field:  "Recharge",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateRechargeResponseValidationError{
					field:  "Recharge",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRecharge()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateRechargeResponseValidationError{
				field:  "Recharge",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CheckoutInfo

	if len(errors) > 0 {
		return CreateRechargeResponseMultiError(errors)
	}

	return nil
}

// CreateRechargeResponseMultiError is an error wrapping multiple validation
// errors returned by CreateRechargeResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateRechargeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRechargeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRechargeResponseMultiError) AllErrors() []error { return m }

// CreateRechargeResponseValidationError is the validation error returned by
// CreateRechargeResponse.Validate if the designated constraints aren't met.
type CreateRechargeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRechargeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRechargeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRechargeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRechargeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRechargeResponseValidationError) ErrorName() string {
	return "CreateRechargeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateRechargeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRechargeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRechargeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRechargeResponseValidationError{}

// Validate checks the field values on GetRechargeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetRechargeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRechargeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetRechargeRequestMultiError, or nil if none found.
func (m *GetRechargeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRechargeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GetRechargeRequest_Name_Pattern.MatchString(m.GetName()) {
		err := GetRechargeRequestValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^users/[A-Za-z0-9_-]+/wallet/recharges/[A-Za-z0-9_-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Fields != nil {

		if all {
			switch v := interface{}(m.GetFields()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetRechargeRequestValidationError{
						field:  "Fields",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetRechargeRequestValidationError{
						field:  "Fields",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFields()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetRechargeRequestValidationError{
					field:  "Fields",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetRechargeRequestMultiError(errors)
	}

	return nil
}

// GetRechargeRequestMultiError is an error wrapping multiple validation errors
// returned by GetRechargeRequest.ValidateAll() if the designated constraints
// aren't met.
type GetRechargeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRechargeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRechargeRequestMultiError) AllErrors() []error { return m }

// GetRechargeRequestValidationError is the validation error returned by
// GetRechargeRequest.Validate if the designated constraints aren't met.
type GetRechargeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRechargeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRechargeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRechargeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRechargeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRechargeRequestValidationError) ErrorName() string {
	return "GetRechargeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetRechargeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRechargeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRechargeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRechargeRequestValidationError{}

var _GetRechargeRequest_Name_Pattern = regexp.MustCompile("^users/[A-Za-z0-9_-]+/wallet/recharges/[A-Za-z0-9_-]+$")

// Validate checks the field values on GetRechargeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetRechargeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRechargeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetRechargeResponseMultiError, or nil if none found.
func (m *GetRechargeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRechargeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetRecharge() == nil {
		err := GetRechargeResponseValidationError{
			field:  "Recharge",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRecharge()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetRechargeResponseValidationError{
					field:  "Recharge",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetRechargeResponseValidationError{
					field:  "Recharge",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRecharge()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetRechargeResponseValidationError{
				field:  "Recharge",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetRechargeResponseMultiError(errors)
	}

	return nil
}

// GetRechargeResponseMultiError is an error wrapping multiple validation
// errors returned by GetRechargeResponse.ValidateAll() if the designated
// constraints aren't met.
type GetRechargeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRechargeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRechargeResponseMultiError) AllErrors() []error { return m }

// GetRechargeResponseValidationError is the validation error returned by
// GetRechargeResponse.Validate if the designated constraints aren't met.
type GetRechargeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRechargeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRechargeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRechargeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRechargeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRechargeResponseValidationError) ErrorName() string {
	return "GetRechargeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetRechargeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRechargeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRechargeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRechargeResponseValidationError{}

// Validate checks the field values on ListRechargesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListRechargesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRechargesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRechargesRequestMultiError, or nil if none found.
func (m *ListRechargesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRechargesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ListRechargesRequest_Parent_Pattern.MatchString(m.GetParent()) {
		err := ListRechargesRequestValidationError{
			field:  "Parent",
			reason: "value does not match regex pattern \"^users/[A-Za-z0-9_-]+/wallet\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PageSize

	// no validation rules for PageToken

	if all {
		switch v := interface{}(m.GetFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListRechargesRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListRechargesRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListRechargesRequestValidationError{
				field:  "Filter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Fields != nil {

		if all {
			switch v := interface{}(m.GetFields()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListRechargesRequestValidationError{
						field:  "Fields",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListRechargesRequestValidationError{
						field:  "Fields",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFields()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListRechargesRequestValidationError{
					field:  "Fields",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListRechargesRequestMultiError(errors)
	}

	return nil
}

// ListRechargesRequestMultiError is an error wrapping multiple validation
// errors returned by ListRechargesRequest.ValidateAll() if the designated
// constraints aren't met.
type ListRechargesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRechargesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRechargesRequestMultiError) AllErrors() []error { return m }

// ListRechargesRequestValidationError is the validation error returned by
// ListRechargesRequest.Validate if the designated constraints aren't met.
type ListRechargesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRechargesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRechargesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRechargesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRechargesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRechargesRequestValidationError) ErrorName() string {
	return "ListRechargesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListRechargesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRechargesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRechargesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRechargesRequestValidationError{}

var _ListRechargesRequest_Parent_Pattern = regexp.MustCompile("^users/[A-Za-z0-9_-]+/wallet")

// Validate checks the field values on ListRechargesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListRechargesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRechargesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRechargesResponseMultiError, or nil if none found.
func (m *ListRechargesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRechargesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRecharges() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListRechargesResponseValidationError{
						field:  fmt.Sprintf("Recharges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListRechargesResponseValidationError{
						field:  fmt.Sprintf("Recharges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListRechargesResponseValidationError{
					field:  fmt.Sprintf("Recharges[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return ListRechargesResponseMultiError(errors)
	}

	return nil
}

// ListRechargesResponseMultiError is an error wrapping multiple validation
// errors returned by ListRechargesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListRechargesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRechargesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRechargesResponseMultiError) AllErrors() []error { return m }

// ListRechargesResponseValidationError is the validation error returned by
// ListRechargesResponse.Validate if the designated constraints aren't met.
type ListRechargesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRechargesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRechargesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRechargesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRechargesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRechargesResponseValidationError) ErrorName() string {
	return "ListRechargesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListRechargesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRechargesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRechargesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRechargesResponseValidationError{}

// Validate checks the field values on CreatePayoutRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreatePayoutRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePayoutRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatePayoutRequestMultiError, or nil if none found.
func (m *CreatePayoutRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePayoutRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequestId

	if !_CreatePayoutRequest_Parent_Pattern.MatchString(m.GetParent()) {
		err := CreatePayoutRequestValidationError{
			field:  "Parent",
			reason: "value does not match regex pattern \"^users/[A-Za-z0-9_-]+/wallet$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPayout() == nil {
		err := CreatePayoutRequestValidationError{
			field:  "Payout",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPayout()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePayoutRequestValidationError{
					field:  "Payout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePayoutRequestValidationError{
					field:  "Payout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePayoutRequestValidationError{
				field:  "Payout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreatePayoutRequestMultiError(errors)
	}

	return nil
}

// CreatePayoutRequestMultiError is an error wrapping multiple validation
// errors returned by CreatePayoutRequest.ValidateAll() if the designated
// constraints aren't met.
type CreatePayoutRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePayoutRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePayoutRequestMultiError) AllErrors() []error { return m }

// CreatePayoutRequestValidationError is the validation error returned by
// CreatePayoutRequest.Validate if the designated constraints aren't met.
type CreatePayoutRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePayoutRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePayoutRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePayoutRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePayoutRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePayoutRequestValidationError) ErrorName() string {
	return "CreatePayoutRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreatePayoutRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePayoutRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePayoutRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePayoutRequestValidationError{}

var _CreatePayoutRequest_Parent_Pattern = regexp.MustCompile("^users/[A-Za-z0-9_-]+/wallet$")

// Validate checks the field values on CreatePayoutResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreatePayoutResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePayoutResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatePayoutResponseMultiError, or nil if none found.
func (m *CreatePayoutResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePayoutResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPayout() == nil {
		err := CreatePayoutResponseValidationError{
			field:  "Payout",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPayout()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePayoutResponseValidationError{
					field:  "Payout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePayoutResponseValidationError{
					field:  "Payout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePayoutResponseValidationError{
				field:  "Payout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreatePayoutResponseMultiError(errors)
	}

	return nil
}

// CreatePayoutResponseMultiError is an error wrapping multiple validation
// errors returned by CreatePayoutResponse.ValidateAll() if the designated
// constraints aren't met.
type CreatePayoutResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePayoutResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePayoutResponseMultiError) AllErrors() []error { return m }

// CreatePayoutResponseValidationError is the validation error returned by
// CreatePayoutResponse.Validate if the designated constraints aren't met.
type CreatePayoutResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePayoutResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePayoutResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePayoutResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePayoutResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePayoutResponseValidationError) ErrorName() string {
	return "CreatePayoutResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreatePayoutResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePayoutResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePayoutResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePayoutResponseValidationError{}

// Validate checks the field values on GetPayoutRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetPayoutRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPayoutRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetPayoutRequestMultiError, or nil if none found.
func (m *GetPayoutRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPayoutRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GetPayoutRequest_Name_Pattern.MatchString(m.GetName()) {
		err := GetPayoutRequestValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^users/[A-Za-z0-9_-]+/wallet/payouts/[A-Za-z0-9_-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Fields != nil {

		if all {
			switch v := interface{}(m.GetFields()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetPayoutRequestValidationError{
						field:  "Fields",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetPayoutRequestValidationError{
						field:  "Fields",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFields()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetPayoutRequestValidationError{
					field:  "Fields",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetPayoutRequestMultiError(errors)
	}

	return nil
}

// GetPayoutRequestMultiError is an error wrapping multiple validation errors
// returned by GetPayoutRequest.ValidateAll() if the designated constraints
// aren't met.
type GetPayoutRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPayoutRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPayoutRequestMultiError) AllErrors() []error { return m }

// GetPayoutRequestValidationError is the validation error returned by
// GetPayoutRequest.Validate if the designated constraints aren't met.
type GetPayoutRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPayoutRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPayoutRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPayoutRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPayoutRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPayoutRequestValidationError) ErrorName() string { return "GetPayoutRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetPayoutRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPayoutRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPayoutRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPayoutRequestValidationError{}

var _GetPayoutRequest_Name_Pattern = regexp.MustCompile("^users/[A-Za-z0-9_-]+/wallet/payouts/[A-Za-z0-9_-]+$")

// Validate checks the field values on GetPayoutResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetPayoutResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPayoutResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetPayoutResponseMultiError, or nil if none found.
func (m *GetPayoutResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPayoutResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPayout() == nil {
		err := GetPayoutResponseValidationError{
			field:  "Payout",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPayout()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetPayoutResponseValidationError{
					field:  "Payout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetPayoutResponseValidationError{
					field:  "Payout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetPayoutResponseValidationError{
				field:  "Payout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetPayoutResponseMultiError(errors)
	}

	return nil
}

// GetPayoutResponseMultiError is an error wrapping multiple validation errors
// returned by GetPayoutResponse.ValidateAll() if the designated constraints
// aren't met.
type GetPayoutResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPayoutResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPayoutResponseMultiError) AllErrors() []error { return m }

// GetPayoutResponseValidationError is the validation error returned by
// GetPayoutResponse.Validate if the designated constraints aren't met.
type GetPayoutResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPayoutResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPayoutResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPayoutResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPayoutResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPayoutResponseValidationError) ErrorName() string {
	return "GetPayoutResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetPayoutResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPayoutResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPayoutResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPayoutResponseValidationError{}

// Validate checks the field values on ListPayoutsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListPayoutsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPayoutsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPayoutsRequestMultiError, or nil if none found.
func (m *ListPayoutsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPayoutsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ListPayoutsRequest_Parent_Pattern.MatchString(m.GetParent()) {
		err := ListPayoutsRequestValidationError{
			field:  "Parent",
			reason: "value does not match regex pattern \"^users/[A-Za-z0-9_-]+/wallet\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PageSize

	// no validation rules for PageToken

	if all {
		switch v := interface{}(m.GetFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListPayoutsRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListPayoutsRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListPayoutsRequestValidationError{
				field:  "Filter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Fields != nil {

		if all {
			switch v := interface{}(m.GetFields()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListPayoutsRequestValidationError{
						field:  "Fields",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListPayoutsRequestValidationError{
						field:  "Fields",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFields()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListPayoutsRequestValidationError{
					field:  "Fields",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListPayoutsRequestMultiError(errors)
	}

	return nil
}

// ListPayoutsRequestMultiError is an error wrapping multiple validation errors
// returned by ListPayoutsRequest.ValidateAll() if the designated constraints
// aren't met.
type ListPayoutsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPayoutsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPayoutsRequestMultiError) AllErrors() []error { return m }

// ListPayoutsRequestValidationError is the validation error returned by
// ListPayoutsRequest.Validate if the designated constraints aren't met.
type ListPayoutsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPayoutsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPayoutsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPayoutsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPayoutsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPayoutsRequestValidationError) ErrorName() string {
	return "ListPayoutsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListPayoutsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPayoutsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPayoutsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPayoutsRequestValidationError{}

var _ListPayoutsRequest_Parent_Pattern = regexp.MustCompile("^users/[A-Za-z0-9_-]+/wallet")

// Validate checks the field values on ListPayoutsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListPayoutsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPayoutsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPayoutsResponseMultiError, or nil if none found.
func (m *ListPayoutsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPayoutsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPayouts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListPayoutsResponseValidationError{
						field:  fmt.Sprintf("Payouts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListPayoutsResponseValidationError{
						field:  fmt.Sprintf("Payouts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListPayoutsResponseValidationError{
					field:  fmt.Sprintf("Payouts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return ListPayoutsResponseMultiError(errors)
	}

	return nil
}

// ListPayoutsResponseMultiError is an error wrapping multiple validation
// errors returned by ListPayoutsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListPayoutsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPayoutsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPayoutsResponseMultiError) AllErrors() []error { return m }

// ListPayoutsResponseValidationError is the validation error returned by
// ListPayoutsResponse.Validate if the designated constraints aren't met.
type ListPayoutsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPayoutsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPayoutsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPayoutsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPayoutsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPayoutsResponseValidationError) ErrorName() string {
	return "ListPayoutsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListPayoutsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPayoutsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPayoutsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPayoutsResponseValidationError{}

// Validate checks the field values on CreatePayoutAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreatePayoutAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePayoutAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatePayoutAccountRequestMultiError, or nil if none found.
func (m *CreatePayoutAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePayoutAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequestId

	if m.GetPayoutAccount() == nil {
		err := CreatePayoutAccountRequestValidationError{
			field:  "PayoutAccount",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPayoutAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePayoutAccountRequestValidationError{
					field:  "PayoutAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePayoutAccountRequestValidationError{
					field:  "PayoutAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayoutAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePayoutAccountRequestValidationError{
				field:  "PayoutAccount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreatePayoutAccountRequestMultiError(errors)
	}

	return nil
}

// CreatePayoutAccountRequestMultiError is an error wrapping multiple
// validation errors returned by CreatePayoutAccountRequest.ValidateAll() if
// the designated constraints aren't met.
type CreatePayoutAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePayoutAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePayoutAccountRequestMultiError) AllErrors() []error { return m }

// CreatePayoutAccountRequestValidationError is the validation error returned
// by CreatePayoutAccountRequest.Validate if the designated constraints aren't met.
type CreatePayoutAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePayoutAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePayoutAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePayoutAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePayoutAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePayoutAccountRequestValidationError) ErrorName() string {
	return "CreatePayoutAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreatePayoutAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePayoutAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePayoutAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePayoutAccountRequestValidationError{}

// Validate checks the field values on CreatePayoutAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreatePayoutAccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePayoutAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatePayoutAccountResponseMultiError, or nil if none found.
func (m *CreatePayoutAccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePayoutAccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPayoutAccount() == nil {
		err := CreatePayoutAccountResponseValidationError{
			field:  "PayoutAccount",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPayoutAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePayoutAccountResponseValidationError{
					field:  "PayoutAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePayoutAccountResponseValidationError{
					field:  "PayoutAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayoutAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePayoutAccountResponseValidationError{
				field:  "PayoutAccount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreatePayoutAccountResponseMultiError(errors)
	}

	return nil
}

// CreatePayoutAccountResponseMultiError is an error wrapping multiple
// validation errors returned by CreatePayoutAccountResponse.ValidateAll() if
// the designated constraints aren't met.
type CreatePayoutAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePayoutAccountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePayoutAccountResponseMultiError) AllErrors() []error { return m }

// CreatePayoutAccountResponseValidationError is the validation error returned
// by CreatePayoutAccountResponse.Validate if the designated constraints
// aren't met.
type CreatePayoutAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePayoutAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePayoutAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePayoutAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePayoutAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePayoutAccountResponseValidationError) ErrorName() string {
	return "CreatePayoutAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreatePayoutAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePayoutAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePayoutAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePayoutAccountResponseValidationError{}

// Validate checks the field values on GetPayoutAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetPayoutAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPayoutAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetPayoutAccountRequestMultiError, or nil if none found.
func (m *GetPayoutAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPayoutAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GetPayoutAccountRequest_Name_Pattern.MatchString(m.GetName()) {
		err := GetPayoutAccountRequestValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^users/[A-Za-z0-9_-]+/wallet/payout-account$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Fields != nil {

		if all {
			switch v := interface{}(m.GetFields()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetPayoutAccountRequestValidationError{
						field:  "Fields",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetPayoutAccountRequestValidationError{
						field:  "Fields",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFields()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetPayoutAccountRequestValidationError{
					field:  "Fields",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetPayoutAccountRequestMultiError(errors)
	}

	return nil
}

// GetPayoutAccountRequestMultiError is an error wrapping multiple validation
// errors returned by GetPayoutAccountRequest.ValidateAll() if the designated
// constraints aren't met.
type GetPayoutAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPayoutAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPayoutAccountRequestMultiError) AllErrors() []error { return m }

// GetPayoutAccountRequestValidationError is the validation error returned by
// GetPayoutAccountRequest.Validate if the designated constraints aren't met.
type GetPayoutAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPayoutAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPayoutAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPayoutAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPayoutAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPayoutAccountRequestValidationError) ErrorName() string {
	return "GetPayoutAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetPayoutAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPayoutAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPayoutAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPayoutAccountRequestValidationError{}

var _GetPayoutAccountRequest_Name_Pattern = regexp.MustCompile("^users/[A-Za-z0-9_-]+/wallet/payout-account$")

// Validate checks the field values on GetPayoutAccountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetPayoutAccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPayoutAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetPayoutAccountResponseMultiError, or nil if none found.
func (m *GetPayoutAccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPayoutAccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPayoutAccount() == nil {
		err := GetPayoutAccountResponseValidationError{
			field:  "PayoutAccount",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPayoutAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetPayoutAccountResponseValidationError{
					field:  "PayoutAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetPayoutAccountResponseValidationError{
					field:  "PayoutAccount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayoutAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetPayoutAccountResponseValidationError{
				field:  "PayoutAccount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetPayoutAccountResponseMultiError(errors)
	}

	return nil
}

// GetPayoutAccountResponseMultiError is an error wrapping multiple validation
// errors returned by GetPayoutAccountResponse.ValidateAll() if the designated
// constraints aren't met.
type GetPayoutAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPayoutAccountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPayoutAccountResponseMultiError) AllErrors() []error { return m }

// GetPayoutAccountResponseValidationError is the validation error returned by
// GetPayoutAccountResponse.Validate if the designated constraints aren't met.
type GetPayoutAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPayoutAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPayoutAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPayoutAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPayoutAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPayoutAccountResponseValidationError) ErrorName() string {
	return "GetPayoutAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetPayoutAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPayoutAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPayoutAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPayoutAccountResponseValidationError{}

// Validate checks the field values on CreateTransactionsRequest_Entry with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTransactionsRequest_Entry) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTransactionsRequest_Entry with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateTransactionsRequest_EntryMultiError, or nil if none found.
func (m *CreateTransactionsRequest_Entry) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionsRequest_Entry) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_CreateTransactionsRequest_Entry_Parent_Pattern.MatchString(m.GetParent()) {
		err := CreateTransactionsRequest_EntryValidationError{
			field:  "Parent",
			reason: "value does not match regex pattern \"^users/[A-Za-z0-9_-]+/wallet$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetTransaction() == nil {
		err := CreateTransactionsRequest_EntryValidationError{
			field:  "Transaction",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTransactionsRequest_EntryValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTransactionsRequest_EntryValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTransactionsRequest_EntryValidationError{
				field:  "Transaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTransactionsRequest_EntryMultiError(errors)
	}

	return nil
}

// CreateTransactionsRequest_EntryMultiError is an error wrapping multiple
// validation errors returned by CreateTransactionsRequest_Entry.ValidateAll()
// if the designated constraints aren't met.
type CreateTransactionsRequest_EntryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionsRequest_EntryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionsRequest_EntryMultiError) AllErrors() []error { return m }

// CreateTransactionsRequest_EntryValidationError is the validation error
// returned by CreateTransactionsRequest_Entry.Validate if the designated
// constraints aren't met.
type CreateTransactionsRequest_EntryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionsRequest_EntryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionsRequest_EntryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionsRequest_EntryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionsRequest_EntryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionsRequest_EntryValidationError) ErrorName() string {
	return "CreateTransactionsRequest_EntryValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionsRequest_EntryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionsRequest_Entry.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionsRequest_EntryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionsRequest_EntryValidationError{}

var _CreateTransactionsRequest_Entry_Parent_Pattern = regexp.MustCompile("^users/[A-Za-z0-9_-]+/wallet$")

// Validate checks the field values on ListRechargesRequest_Filter with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListRechargesRequest_Filter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRechargesRequest_Filter with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRechargesRequest_FilterMultiError, or nil if none found.
func (m *ListRechargesRequest_Filter) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRechargesRequest_Filter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Status != nil {
		// no validation rules for Status
	}

	if m.CreateTime != nil {

		if all {
			switch v := interface{}(m.GetCreateTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListRechargesRequest_FilterValidationError{
						field:  "CreateTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListRechargesRequest_FilterValidationError{
						field:  "CreateTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListRechargesRequest_FilterValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.TransactionId != nil {
		// no validation rules for TransactionId
	}

	if len(errors) > 0 {
		return ListRechargesRequest_FilterMultiError(errors)
	}

	return nil
}

// ListRechargesRequest_FilterMultiError is an error wrapping multiple
// validation errors returned by ListRechargesRequest_Filter.ValidateAll() if
// the designated constraints aren't met.
type ListRechargesRequest_FilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRechargesRequest_FilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRechargesRequest_FilterMultiError) AllErrors() []error { return m }

// ListRechargesRequest_FilterValidationError is the validation error returned
// by ListRechargesRequest_Filter.Validate if the designated constraints
// aren't met.
type ListRechargesRequest_FilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRechargesRequest_FilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRechargesRequest_FilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRechargesRequest_FilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRechargesRequest_FilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRechargesRequest_FilterValidationError) ErrorName() string {
	return "ListRechargesRequest_FilterValidationError"
}

// Error satisfies the builtin error interface
func (e ListRechargesRequest_FilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRechargesRequest_Filter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRechargesRequest_FilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRechargesRequest_FilterValidationError{}

// Validate checks the field values on ListPayoutsRequest_Filter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListPayoutsRequest_Filter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPayoutsRequest_Filter with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPayoutsRequest_FilterMultiError, or nil if none found.
func (m *ListPayoutsRequest_Filter) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPayoutsRequest_Filter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Status != nil {
		// no validation rules for Status
	}

	if m.CreateTime != nil {

		if all {
			switch v := interface{}(m.GetCreateTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListPayoutsRequest_FilterValidationError{
						field:  "CreateTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListPayoutsRequest_FilterValidationError{
						field:  "CreateTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListPayoutsRequest_FilterValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.TransactionId != nil {
		// no validation rules for TransactionId
	}

	if len(errors) > 0 {
		return ListPayoutsRequest_FilterMultiError(errors)
	}

	return nil
}

// ListPayoutsRequest_FilterMultiError is an error wrapping multiple validation
// errors returned by ListPayoutsRequest_Filter.ValidateAll() if the
// designated constraints aren't met.
type ListPayoutsRequest_FilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPayoutsRequest_FilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPayoutsRequest_FilterMultiError) AllErrors() []error { return m }

// ListPayoutsRequest_FilterValidationError is the validation error returned by
// ListPayoutsRequest_Filter.Validate if the designated constraints aren't met.
type ListPayoutsRequest_FilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPayoutsRequest_FilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPayoutsRequest_FilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPayoutsRequest_FilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPayoutsRequest_FilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPayoutsRequest_FilterValidationError) ErrorName() string {
	return "ListPayoutsRequest_FilterValidationError"
}

// Error satisfies the builtin error interface
func (e ListPayoutsRequest_FilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPayoutsRequest_Filter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPayoutsRequest_FilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPayoutsRequest_FilterValidationError{}
